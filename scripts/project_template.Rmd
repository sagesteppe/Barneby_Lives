---
title: "Barneby Lives usage example"
author: "steppe"
date: "`r Sys.Date()`"
output: html_document
---


```{r}
library(tidyverse)
library(sf)
source('functions.R')
```


```{r dummy data}
dummy_pts <- data.frame(
  collectionNo = paste0(rep('RCB', 1000), seq(1:1000)),
  day = c(sample(1:31, size = 1000, replace = T)),
  month = c(sample(5:10, size = 1000, replace = T)),
  year = 2023,
  longitude = runif(1000, min = -120, max = -100), 
  latitude = runif(1000, min = 35, max = 48)
) %>% sf::st_as_sf(coords = c(x = 'longitude', y = 'latitude'), crs = 4326, remove = F)

```

```{r coordinate parsing if required}

library(parzer)

#' this function parses coordinates from DMS to decimal degrees
#'
#'@param x an input data frame to apply operations too
#'@param lat a name of the column holding the latitude values
#'@param long a name of the colymn holding the longitude values
#'@param dms are coordinates in degrees minutes seconds? TRUE for yes, FALSE for decimal degrees
dms2dd <- function(x, lat, long, dms){
  
  if(missing(lat)){
    lat = colnames(dummy_pts)[grep('lat', colnames(dummy_pts))] }
  if(missing(long)){
    long = colnames(dummy_pts)[grep('long', colnames(dummy_pts))] }
  
  if(missing(dms)){
    dms = long == parzer::parse_lon(long)
  }
  
  if(dms == T){
    x$latitude_dd = parzer::parse_lat(lat)
    x$longitude_dd = parzer::pase_lon(long)
  } else{
    colnames(x)[which(names(x) == lat)] <- 'latitude_dd'
    colnames(x)[which(names(x) == long)] <- 'latitude_dd'
  }
  
#  x[,c('latitude_dd', 'longitude_dd')] <- 
#    sapply(x[c('latitude_dd', 'latitude_dd')], as.numeric)
  
 # if(x$longitude_dd > 0){longitude_dd * -1}; 
#  if(x$latitude_dd < 0){latitude_dd * -1}
  
  # now overwrite the original DMS values in our exact format
  
  return(x)

  latitude_dms = paste0(
    'N ', parzer::pz_degree(x$latitude_dd),
    '°', round(parzer::pz_minute(x$latitude_dd), 2),
    "'", round(parzer::pz_second(x$latitude_dd), 2)
  )

  longitude_dms = paste0(
    'W ', parzer::pz_degree(x$longitude_dd), 
    '°', round(parzer::pz_minute(x$longitude_dd), 2), 
    "'", round(parzer::pz_second(x$longitude_dd), 2)
  )
  
}

out <- dms2dd(dummy_pts)

# str detect the lat column
# str detect the long column
# ensure input lat is North
# ensure input long is West
# str detect the datum column, else assume WGS84

```



```{r date parsing}

fourtet <- data.frame(col_date = c('12/23/2003','07/09/2023', '1/13/2016'),
                      det_date = c('12/25/2003','07/09/2023', '1/13/2016'),
                      tet = c('abc', 'def', 'ggg'))

date_parser(fourtet, coll_date = 'col_date', det_date = 'det_date')

```




```{r Acquire administrative geodata}

places <- sf::st_read('../geodata/places/places.shp', quiet = T)

out1 <- political_grabber(dummy_pts, 'collectionNo')
out2 <- place_grabber(dummy_pts)
out3 <- physical_grabber(dummy_pts)

```

